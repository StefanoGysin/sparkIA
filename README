Por favor, veja o arquivo LICENSE para detalhes sobre cópia e uso.
Consulte o arquivo INSTALL para instruções sobre como compilar.

O que é o BusyBox:

  O BusyBox combina versões reduzidas de muitos utilitários comuns do UNIX em um único
  executável pequeno. Ele fornece substituições minimalistas para a maioria dos
  utilitários que você geralmente encontra em bzip2, coreutils, dhcp, diffutils, e2fsprogs,
  file, findutils, gawk, grep, inetutils, less, modutils, net-tools, procps,
  sed, shadow, sysklogd, sysvinit, tar, util-linux e vim. Os utilitários
  no BusyBox geralmente têm menos opções do que suas contrapartes completas;
  no entanto, as opções incluídas fornecem a funcionalidade esperada
  e se comportam de maneira muito semelhante às suas contrapartes maiores.

  O BusyBox foi escrito com otimização de tamanho e recursos limitados
  em mente, tanto para produzir binários pequenos quanto para reduzir o uso de memória em tempo de execução.
  O BusyBox também é extremamente modular, permitindo que você inclua ou exclua
  comandos (ou recursos) facilmente no momento da compilação. Isso facilita a personalização
  de sistemas embarcados; para criar um sistema funcional, basta adicionar /dev, /etc, e um
  kernel Linux. O BusyBox (geralmente junto com uClibc) também tem sido usado como
  um componente de sistemas de "thin client", distribuições live-CD, discos de resgate,
  instaladores, e assim por diante.

  O BusyBox fornece um ambiente POSIX bastante completo para qualquer sistema pequeno,
  tanto em ambientes embarcados quanto em sistemas mais completos preocupados com
  espaço. O BusyBox está lentamente trabalhando para implementar a especificação completa do Single Unix
  Specification V3 (http://www.opengroup.org/onlinepubs/009695399/), mas ainda não
  chegou lá (e por motivos de tamanho, provavelmente suportará no máximo UTF-8 para
  internacionalização). Também estamos interessados em passar no Linux Test
  Project (http://ltp.sourceforge.net).

----------------

Usando o BusyBox:

  O BusyBox é extremamente configurável. Isso permite incluir apenas os
  componentes e opções que você precisa, reduzindo assim o tamanho do binário. Execute 'make
  config' ou 'make menuconfig' para selecionar a funcionalidade que você deseja
  habilitar. (Veja 'make help' para mais comandos.)

  O comportamento do BusyBox é determinado pelo nome pelo qual é chamado: como
  "cp", ele se comporta como cp, como "sed", ele se comporta como sed, e assim por diante. Chamado
  como "busybox", ele toma o segundo argumento como o nome do applet a
  executar (exemplo: "./busybox ls -l /proc").

  O modo "shell autônomo" é uma maneira fácil de experimentar o BusyBox; este é um
  shell de comando que chama os applets embutidos sem precisar que eles estejam
  instalados no caminho. (Observe que isso requer que /proc esteja montado, se
  estiver testando a partir de um disquete de boot ou em um ambiente chroot.)

  A compilação gera automaticamente um arquivo "busybox.links", usado por
  'make install' para criar links simbólicos para o binário BusyBox para todos os comandos compilados.
  Isso usa a variável de ambiente CONFIG_PREFIX para especificar
  onde instalar, e instala hardlinks ou symlinks dependendo
  das preferências de configuração. (Você também pode executar manualmente
  o script de instalação em "applets/install.sh").

----------------

Baixando o código-fonte atual:

  O código-fonte da versão mais recente, bem como instantâneos diários, podem sempre
  ser baixados de

    http://busybox.net/downloads/

  Você pode navegar pelo código-fonte atualizado e o histórico de alterações online.

    http://git.busybox.net/busybox/

  O acesso GIT anônimo está disponível. Para instruções, confira:

    http://www.busybox.net/source.html

  Para aqueles que estão contribuindo ativamente e gostariam de enviar arquivos,
  veja:

    http://busybox.net/developer.html

  Os desenvolvedores também têm um sistema de rastreamento de bugs e patches
  (https://bugs.busybox.net), embora postar um bug/patch na lista de discussão
  geralmente seja uma maneira mais rápida de corrigi-lo, e o arquivo completo do
  que aconteceu é o changelog do git.

  Nota: se você quiser compilar o BusyBox em um ambiente BusyBox, deve
  selecionar CONFIG_DESKTOP.

----------------

Obtendo ajuda:

  Quando você precisar de ajuda, pode conferir os arquivos da lista de discussão do BusyBox
  em http://busybox.net/lists/busybox/ ou até mesmo participar
  da lista de discussão, se estiver interessado.

----------------

Bugs:

  Se encontrar bugs, envie um relatório de bug detalhado para a lista de discussão do BusyBox
  em busybox@busybox.net. Um relatório de bug bem escrito deve incluir uma
  transcrição de uma sessão de shell que demonstre o comportamento inadequado e permita
  que qualquer outra pessoa reproduza o bug em sua própria máquina. O seguinte é um exemplo:

    para: busybox@busybox.net
    de: diligent@testing.linux.org
    assunto: /bin/date não funciona

    pacote: busybox
    versão: 1.00

    quando eu executo busybox 'date', ele produz resultados inesperados.
    com o gnu date, obtenho a seguinte saída:

	$ date
	sex out  8 14:19:41 mdt 2004

    mas quando uso busybox date, obtenho isto em vez disso:

	$ date
	instrução ilegal

    estou usando debian unstable, versão do kernel 2.4.25-vrs2 em um netwinder,
    e o último uclibc do cvs.

	-diligent

  note a descrição cuidadosa e o uso de exemplos mostrando não apenas o que
  o BusyBox faz, mas também um contra-exemplo mostrando o que um app
  equivalente faz (ou apontando para o texto de um padrão relevante). Relatórios de bugs sem
  tais detalhes podem nunca ser corrigidos... Obrigado por entender.

----------------

Portabilidade:

  O BusyBox é desenvolvido e testado em kernels Linux 2.4 e 2.6, compilado
  com gcc (as otimizações unit-at-a-time na versão 3.4 e posteriores valem
  a atualização, mas versões mais antigas devem funcionar), e vinculado contra
  uClibc (0.9.27 ou superior) ou glibc (2.2 ou superior). Em tal
  ambiente, o conjunto completo de recursos do BusyBox deve funcionar, e se
  algo não funcionar, queremos saber sobre isso para podermos corrigir.

  Existem muitos outros ambientes por aí, nos quais o BusyBox pode compilar
  e executar perfeitamente. Nós simplesmente não os testamos. Como o BusyBox consiste em um
  grande número de applets mais ou menos independentes, a portabilidade é uma questão
  de quais recursos funcionam onde. Alguns applets do BusyBox (como cat e rm) são
  altamente portáteis e provavelmente funcionarão em praticamente qualquer lugar, enquanto outros (como
  insmod e losetup) requerem kernels Linux recentes com bibliotecas C recentes.

  Versões anteriores do Linux e glibc podem ou não funcionar, para qualquer configuração
  dada. O Linux 2.2 ou anterior deve funcionar na maior parte (ainda há
  algum código de suporte em coisas como mount.c), mas isso não é mais regularmente
  testado, e inerentemente não suportará certos recursos (como arquivos longos
  e montagens --bind). O mesmo é verdadeiro para glibc 2.0 e 2.1: espere uma
  maior carga de teste e depuração ao usar essa infraestrutura antiga. (Os desenvolvedores do BusyBox
  não estão muito interessados em suportar essas versões mais antigas, mas
  provavelmente aceitarão pequenos patches autocontidos para corrigir problemas simples.)

  Alguns ambientes não são recomendados. As primeiras versões do uClibc eram bugadas
  e faltavam muitos recursos: atualize. Vincular contra libc5 ou dietlibc não é
  suportado e não é interessante para os desenvolvedores do BusyBox. (O primeiro é
  obsoleto e não tem vantagens conhecidas de tamanho ou recursos sobre o uClibc, o segundo
  tem bugs conhecidos que seus desenvolvedores se recusaram ativamente a corrigir.) Kernels
  Linux antigos (2.0.x e anteriores) são igualmente desinteressantes.

  Em teoria, é possível usar o BusyBox em outros sistemas operacionais (como
  MacOS X, Solaris, Cygwin ou o BSD Fork Du Jour). Isso geralmente envolve
  um kernel diferente e uma biblioteca C diferente ao mesmo tempo. Embora
  deva ser possível portar a maioria do código para funcionar em um desses ambientes,
  não fique surpreso se não funcionar de imediato. Se
  você está interessado nesse tipo de coisa, comece pequeno (selecionando apenas alguns applets)
  e vá avançando.

  Em 2005, Shaun Jackman portou o BusyBox para uma combinação de newlib
  e libgloss, e alguns de seus patches foram integrados.

Hardware suportado:

  O BusyBox, em geral, será compilado em qualquer arquitetura suportada pelo gcc. Nós
  suportamos plataformas de 32 e 64 bits, e sistemas little e big endian.

  Sob kernels Linux 2.4, o carregamento de módulos do kernel foi implementado de forma
  específica à plataforma. O utilitário insmod do BusyBox foi relatado como
  funcionando sob ARM, CRIS, H8/300, x86, ia64, x86_64, m68k, MIPS, PowerPC, S390,
  SH3/4/5, Sparc, e v850e. Qualquer outra coisa provavelmente não funcionará.

  O mecanismo de carregamento de módulos para o kernel 2.6 é muito mais genérico, e
  acreditamos que o suporte ao carregamento de módulos do kernel 2.6.x deve funcionar em todas
  as arquiteturas suportadas pelo kernel.

----------------

Por favor, envie sugestões, relatórios de bugs, insultos e subornos de volta para a lista de discussão
do BusyBox:

	busybox@busybox.net

e/ou mantenedor:

	Denys Vlasenko
	<vda.linux@googlemail.com>
